from __future__ import annotations
import collections
from typing import Dict, Generator, List, Union

from ..utils import geometry
from . import base

GroupList = Union[
    List[geometry.Model],
    Dict[str, base.ModelList]]


class Obj(base.SceneDescription):
    """Y+ forward; Z+ up"""
    groups: Dict[str, Dict[str, geometry.Model]]
    # ^ {"group_name": {"model_name": model}}
    exts_txt = [".obj"]

    def __init__(self):
        self.groups = dict()

    def __repr__(self) -> str:
        num_models = sum(len(ms) for ms in self.groups.values())
        descriptor = f"{len(self.groups)} groups {num_models} models"
        return f"<{self.__class__.__name__} {descriptor} @ 0x{id(self):016X}>"

    def lines(self) -> Generator[str, None, None]:
        yield "# generated by bsp_tool.extensions.geometry"

        def indices(polygon: geometry.Polygon) -> List[int]:
            """rexx magic obj indexing; works for Blender, might break elsewhere"""
            # NOTE: inverts winding order; which is desired
            return range(-1, -(len(polygon.vertices) + 1), -1)

        # TODO: make sure None group is first
        for group_name, models in self.groups.items():
            yield f"g {group_name}"
            for model_name, model in models.items():
                yield f"o {model_name}"
                polygons = collections.defaultdict(list)
                # ^ {Material: [Polygon]}
                for mesh in model.meshes:
                    polygons[mesh.material].extend(mesh.polygons)
                for material in polygons:
                    yield f"usemtl {material.name}"
                    # TODO: generate .mtl files
                    # -- f"mtllib {material.name}.mtl"
                    for polygon in polygons[material]:
                        vertices = [*map(model.apply_transforms, polygon.vertices)]
                        # NOTE: only the first uv can be saved
                        if all(len(v.uv) > 0 for v in vertices):
                            for v in vertices:
                                yield f"v {v.position.x} {v.position.y} {v.position.z}"
                                yield f"vn {v.normal.x} {v.normal.y} {v.normal.z}"
                                yield f"vt {v.uv[0].x} {v.uv[0].y}"
                            yield "f " + " ".join([
                                f"{i}/{i}/{i}" for i in indices(polygon)])
                        else:  # no uv
                            for v in vertices:
                                yield f"v {v.position.x} {v.position.y} {v.position.z}"
                                yield f"vn {v.normal.x} {v.normal.y} {v.normal.z}"
                            yield "f " + " ".join([
                                f"{i}//{i}" for i in indices(polygon)])

    @classmethod
    def from_groups(cls, groups: GroupList) -> Obj:
        out = cls()
        if isinstance(groups, (list, tuple, set)):
            groups = {
                f"group_{i:03d}": group
                for i, group in enumerate(groups)}
        assert isinstance(groups, dict), "'groups' must be a GroupList!"
        out.groups = groups
        return out

    @classmethod
    def from_models(cls, models: base.ModelList) -> Obj:
        if isinstance(models, (list, tuple, set)):
            models = {
                f"model_{i:03d}": model
                for i, model in enumerate(models)}
        assert isinstance(models, dict), "'models' must be a ModelList!"
        return cls.from_groups({"group_000": models})

    # TODO: @classmethod from_text(cls, raw_obj: str) -> Obj:
